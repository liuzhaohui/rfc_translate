# UDT：基于UDP的数据传输协议

## 摘要

本文档描述UDT，暨基于UDP的数据传输协议。UDT被设计为一个替代协议，用于在那些TCP不能很好满足需求的场景。一个最典型场景，也是UDT的初衷：解决在高带宽时延乘积(BDP)网络中，TCP性能低下的问题。另一个重要目标是，允许网络研究人员、学生以及应用开发人员可以方便的实现和部署新的数据传输算法和协议。此外，UDT还能用于更好的支持防火墙穿透。

虽然UDT完全构建在UDP之上，然而UDT是基于连接的、单播、全双工的，同时支持可靠数据流和部分可靠消息传递。UDT的拥塞控制模块是一个开放的框架，可以实现和部署不同的控制算法，并且包含一个原生(默认)的基于AIMD速率控制的算法。

## 1.简介

传输控制协议(TCP)[RFC5681]非常成功，对互联网的流行做出了巨大贡献，当前TCP仍然占据互联网流量的大头。

但TCP并非完美，也不可能适用所有的应用场景。过去几年，随着光纤网络的迅速普及和大量应用的涌现，人们发现随着网络带宽时延乘积的不断增大，TCP逐渐显得低效。TCP的AIMD（加增乘减）算法会将拥塞窗口迅速减小，但却不能快速恢复以消耗可用带宽。理论流水平分析表明，随着BDP增加，TCP更容易受到丢包的影响[LM97]。

解决TCP在高速广域网下的低效问题是UDT的初衷，虽然TCP也有一些变种出现，比如Linux下的BiC TCP [XHR04]和Windows下的Compound TCP [TS06]，但是问题并未得到解决。例如，这些新TCP变种都没有解决RTT不公平，也就是拥有较小RTT的连接会占有更多带宽。

再者，随着互联网进化，对传输协议迟早提出新的挑战和需求。研究人员需要一个能够快速开发和测试新算法和协议的平台。网络研究人员和学生可以使用UDT方便的实现他们在传输协议上的想法，特别是拥塞控制算法和在真实网络中试验。

最后，还有一些其他场景下，UDT比TCP更有帮助，比如基于UDP的协议通常更容易穿透防火墙。另外，TCP的拥塞控制和可靠性控制在VOIP、无线通信等某些特定应用领域不是很好用。应用开发人员可以使用UDT（直接拿来用或者稍作修改）就可以满足需求。

基于这些原因和动机，我们相信有必要设计和开发一种基于UDP的数据传输协议。

就如它的名字显示的那样，UDT只构建与UDP [RFC768]之上，数据和控制包都使用UDP传输。UDT基于连接，这样它可以方便的进行拥塞控制、确保可靠和安全。它是一个单播协议，这里不考虑组播。数据在UDT上传输是全双工的。

UDT支持可靠的数据流和部分可靠的消息传递，数据流语义类似TCP，消息传递语义可以认为是SCTP [RFC4960]的子集。

本文档定义UDT协议规范，详细说明以及性能分析请参考[GG07]，全部功能实现可以访问[[UDT](http://udt.sf.net/)]获取。

## 2.包结构

UDT有两种包：数据包和控制包，通过包头的第一个比特位(标志位比特)进行区分。

数据包头的结构如下图

![image-20200919224236552](/Users/liuzhaohui/Library/Application Support/typora-user-images/image-20200919224236552.png)

数据包头以0开头，接下来的31比特是包序列号(Package Sequence Number)。UDT序列号是基于包的，也就是按照发包的先后顺序，每发送一个包，序列号加1，序列号在达到最大值(2^31-1)之后折返循环。

包头接下来的32比特(Message Number)用于消息传递。前2比特"FF"标记位表示同一消息中包的位置，其中"10"表示第一个包，"01"表示最后一个，"11"表示仅此一个包，"00"表示中间的任意一个包。第三比特"O"表示消息须按序(1)或者不按序(0)发送。如果一个消息按序发送，那么前面的消息必须全部发送成功或者丢弃。剩下的29比特是消息编号，类似包的序列号（但不相关）。一个UDT消息可能包含多个UDT包。

紧接着32比特是包发送时的时间戳(Time Stamp)和目的套接字ID(Destination Socket ID)。时间戳是一个相对值，起始值在连接启动时被设置。UDT和它的控制算法并不强制要求时间戳信息，把它加进来以便用户定义的控制算法可能会需要它(详见第6章)。

目标ID用来在UDP之上做多路复用，同一个UDP端口可以有多个UDT套接字，UDT套接字ID被用来区分不同的UDT连接。

如果UDT包的标志位比特值为1，那么就是控制包，它的结构如下图

![image-20200920082129626](/Users/liuzhaohui/Library/Application Support/typora-user-images/image-20200920082129626.png)

UDT控制包有8种不同类型(Type)，类型信息存放在头部1-15比特位。接下来的字段内容跟包类型不同而不同。前128比特必须存在，由于不同包类型差异，控制信息字段(Control Informatioin Field)可能为空。

特别注意，UDT的应答包使用子序列，每个应答包会生成一个16比特唯一且递增的、独立于数据包序列号的序列号。应答序列号使用控制包头的32-63比特位，其范围是0至(2^31-1)。

类型 0x0：协议连接握手

​					扩展信息字段：未定义

​					控制信息字段：

​					1) 32比特：UDT版本号

​					2) 32比特：套接字类型(流或者报文)

​					3) 32比特：初始包序列号

​					4) 32比特：最大包大小(包含UDP/IP包头)

​					5) 32比特：最大流窗口大小

​					6) 32比特：连接类型(正常或者汇聚)

​					7) 32比特：套接字ID

​					8) 32比特：SYN cookie

​					9) 128比特：UDT套接字对端的IP地址

类型0x1：保持存活

​					扩展信息字段：未定义

​					控制信息字段：空

类型0x2：应答(ACK)

​					扩展信息字段：ACK序列号

​					控制信息字段：

​					1) 32比特：该序列号(不含)之前的包都已经收到

​					以下字段为可选

​					2) 32比特：RTT(微秒)

​					3) 32比特：RTT差额

​					4) 32比特：可用缓存大小(字节)

​					5) 32比特：包接收速率(每秒接收包的数目)

​					6) 32比特：预估链路容量(每秒接收包的数目)

类型0x3：否认应答(NAK)

​					扩展信息字段：未定义

​					控制信息字段：

​					1) 32比特压缩的丢失信息整型数组（参见3.9节）

类型0x4：未使用

类型0x5：关闭

​					扩展信息字段：未定义

​					控制信息字段：空

类型0x6：应答的应答(ACK2)

​					扩展信息字段：ACK序列号

​					控制信息字段：空

类型0x7：消息丢弃请求

​					扩展信息字段：消息ID

​					控制信息字段：

​					1) 32比特：消息中的第一个序列号

​					2) 32比特：消息中的最后一个序列号

类型0x7FFF：由16-31比特进一步解释，保留给用户定义的控制包

最后，控制包中也有时间戳和目的套接字ID字段。

## 3.UDP多路选择器

UDP多路选择器用于处理多路UDT连接并发共享同一个UDP端口。多路选择器根据UDT头包的目的套接字ID把包分发到对应的UDT套接字上。

相同UDP端口的所有UDT链接对应一个多路选择器，不同端口的UDT包由不同的多路选择器处理。

一个多路选择器有两个队列，发送队列包含那些至少有一个包需要发送的套接字。发送队列里的UDT套接字按照要发送的下一个包的发送时间序排列。发送队列里维护一个高性能计时器，当第一个套接字发送包的时间到了，则将包发送出去并把套接字从队列移出，如果该套接字还有包需要发送，那么则把套接字重新插入到队列。

接收队列读取接收到的数据包并分发给对应的套接字。如果目标ID为0，那么则分发给监听套接字(如果有的话)，或者分发给汇聚连接状态的套接字(参见第5章)。

跟发送队列类似，接收队列也维护着一个等到接收包的套接字列表。接收队列每隔SYN(SYN=0.01秒，在第4章定义)，扫描队列里所有套接字，看看是它们的定时器超时。

## 4.定时器

UDT用4个定时器来触发不同的周期性事件。每个事件都相互独立且有自己的周期。它们使用系统时间作为时间源，当系统时间折返时也跟着进行折返处理。

某个周期时间E，假设时间变量为ET、周期为p，如果E在系统时间t0时刻设置或者重置(ET=t0)，那么在任意t1时刻，满足条件(t1 - ET >= p)则会触发E时间。

4个定时器分别是ACK，NAK，EXP和SND。SND用于发送者且仅针对基于速率的包发送，而其他三个定时器则只用于接收者。

ACK定时器用于触发应答(ACK)，它的周期由拥塞控制模块设置。尽管拥塞控制不需要基于定时器的ACK，但是UDT会每隔不超过0.01秒就发送一个ACK包。这里，0.01秒被定义为SYN时间（同步时间），它影响着UDT中许多其他定时器。

NAK定时器用于触发否定应答(NAK)，它的周期动态更新为 4 * RTT_ + RTTVar + SYN，其中RTTVar是RTT样本方差。

EXP定时器用于触发数据包重传和维持连接状态，它的周期动态更新为 N * (4 * RTT + RTTVar + SYN)，其中N是连续超时次数。为了避免不必要的超时，实现时应该设置一个最小阈值(例如0.5秒)。

周期粒度建议为微秒，然而除SND外，精准的时间记录是不必要的。

本文档接下来的部分，跟时间相关的变量的名字，可能被用来表示其关联的事件，变量本身，亦或者变量的周期值，要根据其上下文来判断。例如，ACK可能表示ACK事件，或者是ACK周期值。

## 5.连接建立和关闭

UDT支持两种不同的连接建立方式，传统的客户端/服务端模块和汇聚模式。在汇聚模式中，UDT套接字两端(几乎)同时建立连接。

UDT客户端（在汇聚模式，两端都是客户端）发起一个握手请求（类型为0的控制包）给服务端或者对端。握手包包含下列信息（假定UDT套接字A向B发起握手）：

​	1）UDT版本：版本号为了兼容性目的，当前版本为4。

​	2）套接字类型：STREAM(0)或者DGRAM(1)。

​	3）初始序列号：A将发出的第一个数据包的序列号，它应为随机值。

​	4）包大小：一个数据包的最大大小（包含所有包头），通常为MTU。

​	5）最大流窗口大小：该值不是必须的，然而在当前的参考实现里需要。

​	6）连接类型：该信息用户区分连接建立模式和请求/相应。

​	7）套接字ID：客户端UDT的套接字ID。

​	8）Cookie：该Cookie值用于避免SYN洪泛攻击[RFC4987]。

​	9）对端IP地址：B的IP地址。

### 5.1客户端/服务端连接建立

最先有一个UDT实体启动为服务端（监听者），服务端接受和处理连接请求，并为每个新连接创建新的UDT套接字。

客户端想要跟服务端建立连接，首先发送一个握手包。客户端应保持一个固定间隔发送握手包，直到它收到服务端的握手响应或者定时器超时。

当服务器首次接收到客户端的连接请求，它会根据客户端的地址和秘钥生成一个cookie，并发送给客户端。客户端必须把cookie再原样发给服务端。

服务端收到握手包以及正确的cookie，它把包的大小和最大窗口大小跟自己的值相比较，并把自己的值更新为较小的那个。服务端把这个值连同服务端版本号和初始序列号一起，通过握手响应包发送给客户端。这个过程完成之后，服务端即可发送和接收数据。但是，服务端在后续的任何时间收到相同客户端发送的握手包时，它必须即可发送响应包。

客户端一旦收到服务端的握手响应包，它即可发送和接收数据。后续如果收到握手响应消息，它都应忽略。

客户端的连接类型设置为1，服务端响应设置为-1。

客户端应该检查响应是否来自请求发送的目标服务器。

### 5.2汇聚连接建立

在汇聚模式下，两端都同时发送连接请求，初始连接类型设置为0。当一端收到连接请求后，会返回一个应答。如果连接类型为0，那么应答则设置为-1；如果连接类型为-1，那么应答则设置-2；连接类型-1则不发应答。

